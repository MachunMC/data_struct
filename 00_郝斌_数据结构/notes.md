# 概述

## 1. 什么是数据结构？什么是算法？

数据结构研究**数据**和**数据的关系**如何存储，**重点是数据的关系**

为执行某个功能而执行的操作，叫做算法

## 2. 衡量算法的标准

- 时间复杂度：程序要执行的次数，而不是执行的时间
- 空间复杂度：算法执行过程中，占用的最大内存
- 难易程度
- 健壮性

# 线性结构

## 1. 数组

连续存储

### 1.1 数组的优缺点

## 2. 链表

离散存储

### 2.1 定义

- 不连续存储
- 通过指针将所有节点连接在一起
- 每个节点，只有一个前驱节点，也只有一个后续节点（和树的区别）。首节点没有前驱节点，尾节点没有后续节点（环形链表除外）

### 2.2 专业术语

 - 首节点：存放有效数据的第一个节点
 - 尾节点：存放有效数据的最后一个节点
 - **头节点**：一般会在首节点前，加一个不存储有效数据的头节点。增加头节点，方便对链表的操作
 - 头指针：指向头节点的指针
 - 尾指针：指向尾节点的指针

### 2.3 分类

- 单链表：每个节点只有一个指针域，指向后一个结点
- 双链表：每个节点有两个指针域，一个指向后一个节点，一个指向前一个节点
- 循环链表：通过任意一个节点，能找到链表所有的节点
- 非循环链表：通过任意一个节点，无法找到链表的所有节点

### 2.3 操作

- 创建
- 遍历
- 查找
- 求长度
- 排序
- 插入节点
- 删除节点

### 2.4 优缺点

优点

- 空间没有限制
- 插入删除元素很快

缺点

- 存取速度慢

## 3. 线性结构的应用 --- 栈

### 3.1 定义

一种“**先进后出**” 的数据结构，类似于**杯子**

![](https://note.youdao.com/yws/public/resource/a66685a4842f56c1ad2c2aaf50a39424/xmlnote/DB7D603F060E40B2BDBA1632735C553C/28101)

### 3.2 分类

- 静态栈
- 动态栈

### 3.3 操作

- 入栈（压栈）
- 出栈
- 是否为空
- 遍历
- 清空：释放头结点外的所有有效节点，只保留头结点，使pTom等于pBottom
- 销毁：清空栈，并销毁头结点

### 3.4 应用

- 函数调用
- 中断
- 表达式求值
- 内存分配
- 缓冲处理

## 4. 线性结构的应用 --- 队列

### 4.1 定义

一种“**先进先出**”的数据结构，类似于**水管**



![](https://note.youdao.com/yws/public/resource/a66685a4842f56c1ad2c2aaf50a39424/xmlnote/BD51757D46184C66BB68EC7919957E8D/28105)

![](https://note.youdao.com/yws/public/resource/a66685a4842f56c1ad2c2aaf50a39424/xmlnote/72E3F324ADB14F3C808CB95783239F6F/28103)

### 4.2 分类

- 链式队列：用链表实现的队列
- 静态队列：用数组实现的队列，静态队列通常都是**循环队列**

### 4.3 操作

- 入队
- 出队

# 非线性结构

## 1. 树

### 1.1. 定义

有且只有一个根节点，且有若干互不相交的子树，每个子树也是一棵树

### 1.2 专业术语

- 节点
- 父节点
- 子节点
- 兄弟节点
- 叶子节点：没有子节点的节点
- 非终端节点：非叶子节点

- 深度：从根节点到最底层节点的层数
- 度：子节点的最大个数

### 1.3 分类

- 一般树：任意一个节点，子节点个数不受限制

- 二叉树：任意一个节点，最多可以有两个子节点，且子节点的位置不能更改

  - 一般二叉树

  - **满二叉树**：除了叶子节点，其他节点都有两个子节点

    ![](https://note.youdao.com/yws/public/resource/a66685a4842f56c1ad2c2aaf50a39424/xmlnote/D1AC2F45B10343AE95B809FA096DDF9D/28107)

  - **完全二叉树**：除了最后一层外，其他各层的节点都有两个子节点，且最后一层的节点**从左到右连续**分布。满二叉树是一种特殊的完全二叉树

  ![](https://note.youdao.com/yws/public/resource/a66685a4842f56c1ad2c2aaf50a39424/xmlnote/D9F1194C5E9F48F2AA8EC5FE6E77EE82/28109)

- 森林：n个互不相交的树的集合

### 1.4 存储

- 二叉树的存储
  - 连续存储：二叉树用数组存储时，**会添加多余节点**，将普通二叉树转换为**完全二叉树**。如果不转换，后续无法将数组中的值恢复为原来的二叉树。转换为完全二叉树，查找某个节点的父节点或子节点速度非常快。用空间换取时间
  - 链式存储
- 一般树的存储
  - 双亲表示法：求父节点方便
  - 孩子表示法：求子节点方便
  - 双亲孩子表示法：求父节点和子节点方便
  - 二叉树表示法：把一个普通树转换成二叉树。规则为：**每个节点的左指针域指向它的第一个孩子节点，右指针域指向它的下一个兄弟节点**。满足这个条件，就能把一个普通树转换为二叉树。转换后的二叉树没有右子树
- 森林的存储：先把森林转换成二叉树，再存储二叉树。规则：根节点当做兄弟节点，其他规则同上

### 1.5 二叉树的遍历

**记忆方式：前中后表示根节点访问的先后顺序，然后先左再右**

- 前序遍历：根左右
- 中序遍历：左根右
- 后序遍历：左右根



示例：

![](https://note.youdao.com/yws/public/resource/a66685a4842f56c1ad2c2aaf50a39424/xmlnote/096057414BAF4E4599C3AF6747F47620/28113)

- 前序遍历（根左右）：ABDECFG
- 中序遍历（左根右）：DBEAFCG
- 后续遍历（左右根）：DEBFGCA

### 1.6 已知两种遍历顺序，求原始二叉树

通过前序和中序，或者中序和后序，可以求出原始二叉树；但通过前序和后序，无法求出原始二叉树

思路：

	1. 根据前序或后序，先确定根节点
	2. 然后再根据中序确定左右子树
	3. 再根据前序或后序，确定左子树的根节点
	4. 以此类推，最终可以确定原始二叉树



#### 1.6.1 已知前序和中序

示例：

前序：ABDGHCEFI

中序：CDHBAECIF

求后序：GHDBEIFCA

**思路**：

	1. 因为前序是根左右，所以通过前序可以确定根节点
	2. 因为中序是左根右，由于步骤1确定了根节点，所以可以确定左右子树
	3. 根据前序再确定左子树的根节点，在通过中序确定左右子树
	4. 以此类推，最终可以确定原始二叉树

#### 1.6.2 已知中序和后序

示例：

中序：CDHBAECIF

后序：GHDBEIFCA

求前序：ABDGHCEFI

**思路：**

	1. 因为后序是左右根，所以通过后序可以确定根节点
	2. 因为中序是左根右，由于步骤1确定了根节点，所以可以确定左右子树
	3. 根据后序在确定左子树的根节点，再根据中序确定左右子树
	4. 以此类推，最终可以确定原始二叉树



# 排序

排序是查找的前提

## 1. 冒泡排序

### 1.1 原理

按升序排列

1. 假设有n个元素，比较相邻的两个元素，如第一个和第二个比较，如果比第二个大，则交换位置；第二个和第三个比较，如果比第三个大，则交换位置； 以此类推，经过第一轮比较后，最大的排到最后一个位置

2. 第二轮，按照前面的方式，比较除最后一个元素外的n-1个元素，可以将第二大的数排到倒数第二个位置
3. 经过n轮，就可以得到从小到大排列的元素

菜鸟教程排序原理动图可以参考：[1.1 冒泡排序 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/bubble-sort.html)

### 1.2 优化tips

1. 如果序列本身已经是有序的，或者经过几轮排序后是有序的，就不需要再比较了

2. 所以可以增加一个标志，如果本轮排序没有交换过位置，说明序列已经是有序的，不需要交换位置了

## 2. 插入排序

## 3. 选择排序

## 4. 快速排序

## 5. 归并排序

